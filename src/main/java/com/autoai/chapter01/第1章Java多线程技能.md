# 第1章 Java多线程技能

* 线程的启动
* 如何使线程暂停
* 如何使线程停止
* 线程的优先级
* 线程安全相关的问题

## 1.1 进程和多线程的概念及线程的优点

## 1.2 使用多线程

### 1.2.1 继承Thread类

### 1.2.2 实现Runnable接口

### 1.2.3 实例变量与线程安全

* 不共享数据的情况
* 共享数据的情况

在JVM中，i--的操作要分成如下3步：
1）取得原有i值。
2）计算i-1。
3）对i进行赋值。
在这3个步骤中，如果有多个线程同时访问，那么一定会出现非线程安全问题。

示例代码参考example01包

加入synchronized关键字，使多个线程在执行run方法时，以排队的方式进行处理。当一个线程调用run前，先判断run方法有没有被上锁，如果上锁，说明有其他线程正在调用run方法，必须等其他线程对run方法调用结束后才可以执行run方法。这样也就实现了排队调用run方法的目的，也就达到了按顺序对count变量减1的效果了。synchronized可以在任意对象及方法上加锁，而**加锁的这段代码称为“互斥区”或“临界区”**。
当一个线程想要执行同步方法里面的代码时，线程首先尝试去拿这把锁，如果能够拿到这把锁，那么这个线程就可以执行synchronize里面的代码。如果不能拿到这把锁，那么这个线程就会不断地尝试拿这把锁，直到能够拿到为止，而且是有多个线程同时去争抢这把锁。

示例代码参考example02包

### 1.2.4 留意i--与System.out.println()的异常

虽然println（）方法在内部是同步的，但i--的操作却是在进入println（）之前发生的，所以有发生非线程安全问题的概率

## 1.3 currentThread()方法

currentThread（）方法可返回代码段正在被哪个线程调用的信息。

示例代码参考example03包

## 1.4 isAlive()方法

方法isAlive（）的功能是判断当前的线程是否处于活动状态。

示例代码参考example03包

## 1.5 sleep()方法

方法sleep（）的作用是在指定的毫秒数内让当前“正在执行的线程”休眠（暂停执行）。这个“正在执行的线程”是指this.currentThread（）返回的线程。

## 1.6 getId()方法

getId（）方法的作用是取得线程的唯一标识。

## 1.7 停止线程

在Java中有以下3种方法可以终止正在运行的线程：
1）使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。
2）使用stop方法强行终止线程，但是不推荐使用这个方法，因为stop和suspend及resume一样，都是作废过期的方法，使用它们可能产生不可预料的结果。
3）使用interrupt方法中断线程。

### 1.7.1 停止不了的线程

本示例将调用interrupt（）方法来停止线程，但interrupt（）方法的使用效果并不像for+break语句那样，马上就停止循环。调用interrupt（）方法仅仅是在当前线程中打了一个停止的标记，并不是真的停止线程。

示例代码参考example04包InterruptTest#test1

### 1.7.2 判断线程是否是停止状态

先来看一下如何判断线程的状态是不是停止的。在Java的SDK中，Thread.java类里提供了两种方法。
1）this.interrupted（）：测试当前线程是否已经中断。
2）this.isInterrupted（）：测试线程是否已经中断。

`Thread#interrupted`

测试当前线程是否已经中断。线程的中断状态由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。

示例代码参考example04包InterruptTest#test2

`thread#isInterrupted`

示例代码参考example04包InterruptTest#test3

1）this.interrupted（）：测试当前线程是否已经是中断状态，执行后具有将状态标志置清除为false的功能。
2）this.isInterrupted（）：测试线程Thread对象是否已经是中断状态，但不清除状态标志。

### 1.7.3 能停止的线程——异常法

在线程中判断一下线程是否是停止状态，如果是停止状态，则后面的代码不再运行即可。

示例代码参考example04包InterruptTest#test5

### 1.7.4 在沉睡中停止

如果在sleep状态下停止某一线程，会进入catch语句，并且清除停止状态值，使之变成false。

示例代码参考example04包InterruptTest#test6

### 1.7.5 能停止的线程——暴力停止

使用stop（）方法停止线程则是非常暴力的。

示例代码参考example04包StopTest#test1

### 1.7.6 方法stop()与java.lang.ThreadDeath异常

调用stop()方法时会抛出java.lang.ThreadDeath异常，但在通常的情况下，此异常不需要显式地捕捉。
方法stop()已经被作废，因为**如果强制让线程停止则有可能使一些清理性的工作得不到完成**。另外一个情况就是**对锁定的对象进行了“解锁”，导致数据得不到同步的处理，出现数据不一致的问题**。

示例代码参考example04包StopTest#test2

### 1.7.7 释放锁的不良后果

使用stop()释放锁将会给数据造成不一致性的结果。如果出现这样的情况，程序处理的数据就有可能遭到破坏，最终导致程序执行的流程错误，一定要特别注意。

示例代码参考example04包StopTest#stopThrowLock

### 1.7.8 使用return停止线程

将方法interrupt()与return结合使用也能实现停止线程的效果。

示例代码参考example04包InterruptTest#test4

## 1.8 暂停线程

暂停线程意味着此线程还可以恢复运行。在Java多线程中，可以使用suspend()方法暂停线程，使用resume()方法恢复线程的执行。

### 1.8.1 suspend与resume方法的使用

示例代码参考example05包SuspendResumeTest#test1

### 1.8.2 suspend与resume方法的缺点——独占

在使用suspend与resume方法时，如果使用不当，极易造成公共的同步对象的独占，使得其他线程无法访问公共同步对象。

示例代码参考example05包SuspendResumeTest#test2、SuspendResumeTest#test3

### 1.8.3　suspend与resume方法的缺点——不同步

在使用suspend与resume方法时也容易出现因为线程的暂停而导致数据不同步的情况。

示例代码参考example05包SuspendResumeTest#test4

## 1.9 yield方法

yield()方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU执行时间。但放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片。

示例代码参考example06包YieldTest#main

## 1.10 线程的优先级

在操作系统中，线程可以划分优先级，优先级较高的线程得到的CPU资源较多，也就是**CPU优先执行优先级较高的线程对象中的任务**。设置线程优先级有助于帮“线程规划器”确定在下一次选择哪一个线程来优先执行。
设置线程的优先级使用setPriority()方法。在Java中，线程的优先级分为1~10这10个等级，如果小于1或大于10，则JDK抛出异常throw new IllegalArgumentException（）。JDK中使用3个常量来预置定义优先级的值

```java
public final static int MIN_PRIORITY = 1;
public final static int NORM_PRIORITY = 5;
public final static int MAX_PRIORITY = 10;
```

### 1.10.1 线程优先级的继承特性

在Java中，线程的优先级具有继承性，比如A线程启动B线程，则B线程的优先级与A是一样的。

示例代码参考example07包PriorityTest#test1

### 1.10.2 优先级具有规则性

虽然使用setPriority()方法可以设置线程的优先级，但还没有看到设置优先级所带来的效果。

### 1.10.3 优先级具有随机性

线程的优先级还具有“随机性”，也就是优先级较高的线程不一定每一次都先执行完。不要把线程的优先级与运行结果的顺序作为衡量的标准，优先级较高的线程并不一定每一次都先执行完run()方法中的任务，也就是说，线程优先级与打印顺序无关，不要将这两者的关系相关联，它们的关系具有不确定性和随机性。

示例代码参考example07包PriorityTest#test2

## 1.11 守护线程

在Java线程中有两种线程，一种是用户线程，另一种是守护线程。
守护线程是一种特殊的线程，它的特性有“陪伴”的含义，**当进程中不存在非守护线程了，则守护线程自动销毁**。典型的守护线程就是垃圾回收线程，当进程中没有非守护线程了，则垃圾回收线程也就没有存在的必要了，自动销毁。用个比较通俗的比喻来解释一下“守护线程”：任何一个守护线程都是整个JVM中所有非守护线程的“保姆”，只要当前JVM实例中存在任何一个非守护线程没有结束，守护线程就在工作，只有当最后一个非守护线程结束时，守护线程才随着JVM一同结束工作。Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是GC（垃圾回收器），它就是一个很称职的守护者。

示例代码参考example08包DaemonThreadTest#main

## 1.12 本章小结

本章介绍了Thread类的API，在使用这些API的过程中，会出现一些意想不到的情况，其实这也是多线程具有不可预知性的一个体现。学习和掌握这些常用情况，也就掌握了多线程开发的命脉与习性，是学习多线程更深层知识的基础。